var restartBannerTimeout = null;
var currentExtensionColors = {};
var pywalColors = {};
var isThemeApplied = false;

// Get the colors that we want to apply to the Settings page
function getExtensionColorsFromTheme(theme) {
  return {
    background: theme.colors ? theme.colors.frame : DEFAULT_COLORSCHEME.BACKGROUND,
    foreground: theme.colors ? theme.colors.tab_selected : DEFAULT_COLORSCHEME.FOREGROUND,
    backgroundLight: theme.colors ? theme.colors.button_background_hover : DEFAULT_COLORSCHEME.BACKGROUND_LIGHT,
    accentPrimary: theme.colors ? theme.colors.tab_loading : DEFAULT_COLORSCHEME.ACCENT_PRIMARY,
    accentSecondary: theme.colors ? theme.colors.popup_highlight : DEFAULT_COLORSCHEME.ACCENT_SECONDARY,
    text: theme.colors ? theme.colors.toolbar_field_text : DEFAULT_COLORSCHEME.TEXT
  };
}

// Update the CSS-variables in the Settings page to dynamically change the theme
// off the page based on the current selected colors
function setExtensionTheme(extensionColors) {
  document.documentElement.style.setProperty('--background', extensionColors.background);
  document.documentElement.style.setProperty('--background-light', extensionColors.backgroundLight);
  document.documentElement.style.setProperty('--foreground', extensionColors.foreground);
  document.documentElement.style.setProperty('--accent-primary', extensionColors.accentPrimary);
  document.documentElement.style.setProperty('--accent-secondary', extensionColors.accentSecondary);
  document.documentElement.style.setProperty('--text-color', extensionColors.text);
}

// Gets a color generated by pywal
function getPaletteColorById(id) {
  if (pywalColors !== undefined) {
    return pywalColors[id];
  }
}

async function setPaletteColor(preview) {
  if (isThemeApplied) {
    const id = preview.getAttribute('data-id');
    preview.style.backgroundColor = getPaletteColorById(id);
  } else {
    preview.style.backgroundColor = currentExtensionColors.background;
  }
}

async function sendMessageToTabs(data) {
  const tabs = await browser.tabs.query({ url: DDG_URL_PATTERN });

  for (const tab of tabs) {
    browser.tabs.sendMessage(tab.id, data);
  }
}

function setCustomColor(colorKey, color, ddgReload = true) {
  browser.runtime.sendMessage({
    action: 'customColor',
    type: colorKey,
    value: color,
    ddgReload: ddgReload
  });
}

async function setVersionLabel(element) {
  const state = await browser.storage.local.get(['daemonVersion', 'connectedToDaemon']);
  let daemonVersion = 'failed';
  if (state.hasOwnProperty('daemonVersion')) {
    daemonVersion = state.daemonVersion;
  }

  element.innerText = `Addon: ${browser.runtime.getManifest().version} | Daemon: ${daemonVersion} | Connected: ${state.connectedToDaemon}`;
}

// Notification-like message
function showBanner(banner, message) {
  if (restartBannerTimeout === null) {
    banner.innerText = message;
    banner.classList.add('show');
    restartBannerTimeout = setTimeout(() => {
      banner.classList.remove('show');
      restartBannerTimeout = null;
    }, 3000);
  }
}

// Sets the theme of the extension to match the one in the browser
async function loadExtension() {
  const theme = await browser.theme.getCurrent();
  const colors = getExtensionColorsFromTheme(theme);
  const state = await browser.storage.local.get([ 'pywalColors', 'isApplied' ]);

  setExtensionTheme(colors);
  currentExtensionColors = colors;

  if (state.hasOwnProperty('pywalColors')) {
    pywalColors = state.pywalColors;
  } else {
    output('Could not read pywal colors from local storage. Try fetching the colors again')
  }

  if (state.hasOwnProperty('isApplied')) {
    isThemeApplied = state.isApplied;
  } else {
    output('Could not decide if the pywal theme is applied or not. Try fetching the colors again');
  }

  return colors
}

function setupListeners(updateFunction) {
  loadExtension().then(updateFunction);

  const updateButton = document.getElementById('update');
  const resetButton = document.getElementById('reset');

  // Watch for theme updates
  browser.theme.onUpdated.addListener(async ({ theme, windowId }) => {
    const sidebarWindow = await browser.windows.getCurrent();
    if (!windowId || windowId == sidebarWindow.id) {
      loadExtension().then(updateFunction);
    }
  });

  // If we use the "Go back" button, we want to update the interface again,
  // since the user might have updated/reset the theme.
  // https://stackoverflow.com/questions/2638292/after-travelling-back-in-firefox-history-javascript-wont-run
  window.onpageshow = function(event) {
    // The window was loaded from bfcache
    if (event.persisted) {
      loadExtension().then(updateFunction);
    }
  };

  // Setup event listeners for the update and reset buttons, if they exist
  if (updateButton !== null && resetButton !== null) {
    updateButton.addEventListener('click', () => {
      browser.runtime.sendMessage({ action: 'update' });
    });

    resetButton.addEventListener('click', async () => {
      loadExtension().then(updateFunction);
      browser.runtime.sendMessage({ action: 'reset' });
    });
  }
}


